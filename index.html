<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Wrestling Figure Extravaganza!</title>
    <link rel="stylesheet" href="style.css"/>
</head>

<body>
    <div class="main">

        <div class="column">
            <h1>Wrestling Figure Extravaganza!</h1>
            <h2>Json input/output</h2>
            <textarea id="JsonInputField"></textarea>
            <div style="display:inline-block">
                <button onclick="Submit()">Submit</button><button onclick="downloadJSON()">Download JSON</button><button
                    onclick="FixUIDs()">Fix UIDs</button>
            </div>
            <div class="hideUntilData big" style="overflow: auto;">
                <h2>Add New Wrestler</h2>
                <form id="addForm" onsubmit="addEntry(event)">
                    <div class="inline-form"><label>
                            Game:
                            <select id="game">
                            </select>
                        </label></div>
                    <div class="inline-form"><label>
                            UID:
                            <input type='text' oninput='OnUIDEdited()' id='uidInput' list='uidList' />
                            <datalist id="uidList">
                                <!-- Filled using code -->
                            </datalist>
                        </label></div>
                    <div class="inline-form"><label>
                            Display name:
                            <input type="text" id="displayName" required>
                        </label></div>
                    <div class="inline-form"><label>
                            Notes:
                            <input type="text" id="notes">
                        </label></div>
                    <div class="inline-form"><label>
                            Status (Do I have this character?):
                            <input type="checkbox" id="statusCheckbox" checked>
                        </label></div>
                    <div class="inline-form"><label>
                            Legend:
                            <input type="checkbox" id="legendCheckbox">
                        </label></div>
                    <div class="inline-form"><label>
                            In the post?
                            <input type="checkbox" id="inThePostCheckbox">
                        </label></div>
                    <div class="inline-form"><label>
                            Figure details:
                            <input type="text" id="figureDetails">
                        </label></div>
                    <div class="inline-form"><label>
                            Personal ranking:
                            <input type="number" id="personalRanking">
                        </label></div>
                    <button type="submit">Add Wrestler Entry</button>
                </form>
                <h2>Add New Game</h2>
                <form id="addGameForm" onsubmit="AddGame(event)">
                    <div class="inline-form">
                        <label>
                            Game Title:
                            <input type="text" id="newGameFormField">
                        </label>
                        <label for="newGameReleaseDateField">Release Date:</label>
                        <input type="date" id="newGameReleaseDateField" name="newGameReleaseDateField">
                    </div>
                    <button type="submit">Add Game</button>
                </form>
            </div>

        </div>
        <div class="column big hideUntilData">
            <h2>Stats</h2>
            <div id="statsTabs"></div>
            <div class="inline-form"><label>
                    Filter by status:
                    <select id="statsStatusFilter" onchange="OnStatsFilterChange()">
                        <option value="all">All</option>
                        <option value="true">Got</option>
                        <option value="false">Not got</option>
                    </select>
                    Legend:
                    <select id="statsLegendFilter" onchange="OnStatsFilterChange()">
                        <option value="all">All</option>
                        <option value="true">Legends Only</option>
                        <option value="false">Main Roster Only</option>
                    </select>
                    </select>
                    In the post:
                    <select id="statsPostalFilter" onchange="OnStatsFilterChange()">
                        <option value="all">All</option>
                        <option value="true">In the post!</option>
                        <option value="false">Not in the post</option>
                    </select>
                </label></div>
            <div class="output" id="statsContainer" , style="flex-direction: row; padding: 10px; margin:10px">
            </div>
        </div>
        <div class="column hideUntilData" style="max-width: 30%;">
            <h2>Entries</h2>
            <div id="entryTabs"></div>
            <div class="inline-form"><label>
                    Filter by status:
                    <select id="entryStatusFilter" onchange="OnEntriesFilterChange()">
                        <option value="all">All</option>
                        <option value="true">Got</option>
                        <option value="false">Not got</option>
                    </select>
                    Legend:
                    <select id="entryLegendFilter" onchange="OnEntriesFilterChange()">
                        <option value="all">All</option>
                        <option value="true">Legends Only</option>
                        <option value="false">Main Roster Only</option>
                    </select>
                    </select>
                    In the post:
                    <select id="entryPostalFilter" onchange="OnEntriesFilterChange()">
                        <option value="all">All</option>
                        <option value="true">In the post!</option>
                        <option value="false">Not in the post</option>
                    </select>
                </label></div>
            &nbsp;&nbsp;
            <div class="inline-form"><label>
                    Search by name:
                    <input type="text" id="entryNameFilter" oninput="OnEntriesFilterChange()"
                        placeholder="Enter name...">
                </label></div>
            <div id="rosterView" , class="output"></div>
        </div>
    </div>

    <script>

        let knownUIDs = [];
        let games;
        let entryTabsBeingShown = [];
        let statsTabsBeingShown = [];

        //#region JSON I/O
        function UpdateJsonInputFieldAndResubmit() {
            document.getElementById("JsonInputField").value = JSON.stringify(games, null, 2);
            Submit();
        }

        function Submit() {
            const raw = document.getElementById("JsonInputField").value;

            try {
                games = JSON.parse(raw);
            } catch (e) {
                alert("Invalid JSON!");
                return;
            }

            // Sort and rebuild the object
            games = Object.fromEntries(
                Object.entries(games).sort((a, b) => {
                    const dateA = new Date(a[1]["ReleaseDate"] || "2100-01-01");
                    const dateB = new Date(b[1]["ReleaseDate"] || "2100-01-01");
                    return dateA - dateB;
                })
            );
            populateGamesDropdown();
            RebuildKnownUIDs();
            renderUIDDropdown();
            renderEntries();
            renderStats();

            // Unhide UI elements
            Array.from(document.getElementsByClassName("hideUntilData")).forEach(element => {
                element.classList.remove("hideUntilData");
            });
        }




        function downloadJSON() {
            const jsonText = document.getElementById("JsonInputField").value;
            const blob = new Blob([jsonText], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const link = document.createElement("a");
            link.href = url;
            link.download = "wrestling_roster.json";
            link.click();

            URL.revokeObjectURL(url); // Clean up
        }

        function populateGamesDropdown() {
            const gamesDropdown = document.getElementById("game");
            gamesDropdown.innerHTML = "";
            let i = 0;
            Object.keys(games).forEach(element => {
                let opt = document.createElement("option");
                opt.value = element; // the index
                opt.innerHTML = element;
                gamesDropdown.appendChild(opt)
                i++;
            })
        }
        //#endregion

        //#region Add New Entries
        function AddGame(event) {
            event.preventDefault();

            gameTitle = document.getElementById("newGameFormField").value.trim();
            if (!gameTitle) {
                alert("Please enter a display name for the new UID.");
                return;
            }
            else if (games[gameTitle] && !confirm(`There's already a game called ${gameTitle}. Do you want to replace it with a new, empty one?`)) {
                return;
            }
            else if (confirm(`Add a new game called ${gameTitle}?`)) {
                const dates = document.getElementById("newGameReleaseDateField").value;
                games[gameTitle] = {};
                games[gameTitle]["ReleaseDate"] = dates;
                games[gameTitle]["Roster"] = [];
            }
            UpdateJsonInputFieldAndResubmit();
        }

        function addEntry(event) {
            event.preventDefault();

            // Get form values
            const dropdownForGame = document.getElementById("game");
            const game = document.getElementById("game").value.trim();
            let uid = document.getElementById("uidInput").value;

            let displayName;
            displayName = document.getElementById("displayName").value.trim();
            if (!displayName) {
                alert("Please enter a display name for the new UID.");
                return;
            }

            if ((uid == undefined || uid === "" || isNaN(uid))) {
                if (confirm(`Add new UID for ${displayName}?`)) {
                    uid = getNextUID();
                }
                else {
                    return;
                }
            }

            const notes = document.getElementById("notes").value.trim();
            const status = document.getElementById("statusCheckbox").checked;
            const legend = document.getElementById("legendCheckbox").checked;
            const inThePost = document.getElementById("inThePostCheckbox").checked;
            const details = document.getElementById("figureDetails").value.trim();
            const ranking = document.getElementById("personalRanking").value;

            // Build new entry
            const newEntry = {
                "UID": uid,
                "Display Name": displayName,
                "Notes": notes,
                "Status": status,
                "Legend": legend,
                "In The Post": inThePost,
                "Figure Details": details,
                "Personal Ranking": ranking
            };

            if (!games[game]) {
                if (confirm(`Add a new game called ${game}?`)) {
                    games[game] = []; { }
                }
                else { return; }
            }
            games[game]["Roster"].push(newEntry);

            // Update display
            UpdateJsonInputFieldAndResubmit();

            document.getElementById("addForm").reset();
            document.getElementById("game").value = game;
        }

        function renderUIDDropdown() {
            const uidList = document.getElementById("uidList");
            uidList.innerHTML = "";

            knownUIDs.forEach(entry => {
                const option = document.createElement("option");
                option.value = entry.uid;
                option.text = `${entry.uid} - ${entry.name}`;
                uidList.appendChild(option);
            });

            // Add "New UID" option
            const newOption = document.createElement("option");
            newOption.value = "NEW";
            newOption.text = "New UID...";
            uidList.appendChild(newOption);
        }
        //#endregion

        //#region UID Management
        function RebuildKnownUIDs() {
            knownUIDs = [];

            // Build UID list (skip duplicates)
            for (const game in games) {

                const roster = games[game]["Roster"];
                if (roster && roster.length > 0) {

                    for (const entry of roster) {
                        if (entry.UID !== undefined && !knownUIDs.some(u => u.uid === entry.UID)) {
                            knownUIDs.push({
                                uid: entry.UID,
                                name: entry["Display Name"]
                            });
                        }
                    }
                }
                else {
                    console.warn(`No wrestlers found in roster for game ${game}`);
                }
            }
        }

        function getNextUID() {
            const allUIDs = knownUIDs.map(e => parseInt(e.uid)).filter(n => !isNaN(n));
            const maxUID = allUIDs.length ? Math.max(...allUIDs) : 0;
            return (maxUID + 1).toString();
        }

        function FixUIDs() {
            const raw = document.getElementById("JsonInputField").value;

            try {
                games = Object.values(JSON.parse(raw));
            } catch (e) {
                alert("Invalid JSON!");
                return;
            }

            RebuildKnownUIDs(games);
            let issuesFound = 0;

            for (const game in games) {
                const roster = games[game]["Roster"];
            }

            if (issuesFound > 0) {
                if (confirm(`Fix ${issuesFound} broken UID entries?`)) {

                    for (const game in games) {
                        const roster = games[game]["Roster"];
                        roster.forEach(element => {
                            if (element["UID"] == undefined || element["UID"] == "" || isNaN(element["UID"])) {
                                let goodNumber = getNextUID();
                                console.log(`Fixing bad UID for "${element["Display Name"]}": UID was ${element["UID"]}, swapping to ${goodNumber}`);
                                element["UID"] = goodNumber;
                                knownUIDs.push({
                                    uid: element["UID"],
                                    name: element["Display Name"]
                                });
                            }
                        });
                    }
                    UpdateJsonInputFieldAndResubmit();

                }
                else {
                    alert("Cancelled UID fix. No changes made.")
                }
            }
            else {
                alert("No broken UIDs detected. This is good.")
            }
        }

        function OnUIDEdited() {
            var val = document.getElementById("uidInput").value;
            var opts = document.getElementById('uidList').children;
            for (var i = 0; i < opts.length; i++) {
                if (opts[i].value === val) {
                    if (opts[i].value == "NEW") {
                        return;
                    }

                    let displayName = document.getElementById("displayName");

                    const match = knownUIDs.find(entry => entry.uid === opts[i].value);
                    if (match && (displayName.value == undefined || displayName.value == "")) {
                        displayName.value = match.name;
                    }
                    break;
                }
            }
        }
        //#endregion

        //#region Entries
        const entryFilterInputs =
        {
            status: document.getElementById("entryStatusFilter"),
            displayName: document.getElementById("entryNameFilter"),
            legend: document.getElementById("entryLegendFilter"),
            inThePost: document.getElementById("entryPostalFilter")
        }

        function renderEntries() {

            const output = document.getElementById("rosterView");
            output.innerHTML = "";

            const entryFilter =
            {
                "Status": entryFilterInputs.status.value,
                "Display Name": entryFilterInputs.displayName.value.trim().toLowerCase(),
                "Legend": entryFilterInputs.legend.value,
                "In The Post": entryFilterInputs.inThePost.value
            };

            //All games tab
            const tabs = document.getElementById("entryTabs");
            tabs.innerHTML = "";

            CreateTabButton("All Games", () => toggleEntryTabs("All Games"), "EntryTabButton", tabs);

            for (const game in games) {
                const roster = games[game]["Roster"];
                const section = document.createElement("div");

                CreateTabButton(game, () => toggleEntryTabs(game), "EntryTabButton", tabs);


                //Header
                section.id = `Entry${game}Content`;
                section.innerHTML = `<h2>${game}</h2>`;

                let anyMatch = false;

                if (roster) {

                    const sortedRoster = [...roster].sort((a, b) => {
                        return a["Display Name"]?.localeCompare(b["Display Name"]);
                    });


                    sortedRoster.forEach((entry, index) => {
                        const realIndex = roster.indexOf(entry); // Get index from the original unsorted roster
                        if (
                            WrestlerShouldBeShown(entry, entryFilter)
                        ) {
                            anyMatch = true;
                            const div = document.createElement("div");
                            div.classList.add("entry");

                            const uid = entry["UID"] ?? "";
                            const safeUID = uid.replace(/"/g, '&quot;');
                            const safeName = entry["Display Name"]?.replace(/"/g, '&quot;');
                            const safeData = JSON.stringify(entry).replace(/"/g, '&quot;');
                            const safeGame = game.replace(/"/g, '&quot;');

                            div.innerHTML = `
    <form onsubmit="updateEntry(event, '${safeGame}', '${safeUID}', ${realIndex})" data-original='${JSON.stringify(entry).replace(/'/g, "&apos;")}'>            
            <div class="inline-form"><label>
              Name:
              <input type="text" name="displayName" value="${entry["Display Name"] || ""}"">
            </label></div>
            <div class="inline-form"><label>
              Notes:
              <input type="text" name="notes" value="${entry["Notes"] || ""}"">
            </label></div>
            <div class="inline-form"><label>
              Status:
              <input type="checkbox" name="status" ${entry["Status"] ? "checked" : ""}>
            </label></div>
            <div class="inline-form"><label>
                Legend:
                <input type="checkbox" name="legend" ${entry["Legend"] ? "checked" : ""}>
            </label></div>
            <div class="inline-form"><label>
                In the post?
                <input type="checkbox" name="inThePost" ${entry["In The Post"] ? "checked" : ""}>
            </label></div>
            <div class="inline-form"><label>
                Figure details:
                <input type="text" name="figureDetails" value="${entry["Figure Details"] || ""}"">
            </label></div>
            <div class="inline-form"><label>
                Personal ranking:
                <input type="number" name = "personalRanking" value = ${entry["Personal Ranking"] || ""}>
            </label></div>
            ${uid !== "" ? `<strong>UID:</strong> ${safeUID} (${ShowUIDStatusAverageInColourText(safeUID, games)})<br>` : "No ID"}<br>
            <button type="submit">Update</button>
            <button type="button" onclick="deleteEntry('${safeGame}', '${safeUID}', '${safeName}')">Delete</button>
        <button type="button" onclick="resetEntry(this.form, '${safeGame}', ${realIndex})">Reset</button>
        <button type="button"><a href="https://wrestlingfiguredatabase.com/search?q=${safeName}&options%5Bprefix%5D=last" target="_blank">Wrestling Figure Database</a></button>
        <button type="button"><a href="https://www.ebay.co.uk/sch/i.html?_nkw=${safeName}+wrestling+figure" target="_blank">eBay</a></button>
        
                    </form>
        `;
                            const form = div.querySelector("form");
                            trackFormChanges(form);
                            section.appendChild(div);
                        }
                    });
                }
                output.appendChild(section);
            }
            showEntryTabs();
        }

        function showEntryTabs() {
            for (const gameID in games) {
                if (entryTabsBeingShown.length == 0 || arrayContains(gameID, entryTabsBeingShown)) {

                    // Show selected tab and mark button active
                    document.getElementById(`EntryTabButton${gameID}`).classList.add('tab-btn-active');
                    document.getElementById(`EntryTabButton${gameID}`).classList.remove('tab-btn');
                    document.getElementById(`Entry${gameID}Content`).style.display = "block";
                }
                else {
                    document.getElementById(`Entry${gameID}Content`).style.display = "none";
                    document.getElementById(`EntryTabButton${gameID}`).classList.remove('tab-btn-active');
                    document.getElementById(`EntryTabButton${gameID}`).classList.add('tab-btn');

                }
            }
        }

        function resetEntry(form) {
            const originalStr = form.getAttribute("data-original").replace(/&apos;/g, "'");
            const original = JSON.parse(originalStr);

            form.querySelector('[name="displayName"]').value = original["Display Name"];
            form.querySelector('[name="notes"]').value = original["Notes"] || "";
            form.querySelector('[name="status"]').checked = !!original["Status"];
            form.querySelector('[name="legend"]').checked = !!original["Legend"];
            form.querySelector('[name="inThePost"]').checked = !!original["In The Post"];
            form.querySelector('[name="figureDetails"]').checked = !!original["Figure Details"];
            form.querySelector('[name="personalRanking"]').checked = !!original["Personal Ranking"];
            form.parentElement.classList.remove("unsaved");
        }

        function updateEntry(event, game, uid, index) {
            event.preventDefault();

            const form = event.target;
            const displayName = form.displayName.value.trim();
            const notes = form.notes.value.trim();
            const status = form.status.checked;
            const legend = form.legend.checked;
            const inThePost = form.inThePost.checked;
            const figureDetails = form.figureDetails.value.trim();
            const personalRanking = form.personalRanking.value;
            form.parentElement.classList.remove("unsaved");

            if (!displayName) {
                alert("Display name is required.");
                return;
            }

            if (!games[game]) {
                alert("Game not found.");
                return;
            }

            const entries = games[game]["Roster"];

            if (index >= 0 && index < entries.length) {
                entries[index]["Display Name"] = displayName;
                entries[index]["Notes"] = notes;
                entries[index]["Status"] = status;
                entries[index]["Legend"] = legend;
                entries[index]["In The Post"] = inThePost;
                entries[index]["Figure Details"] = figureDetails;
                entries[index]["Personal Ranking"] = personalRanking;
            }

            UpdateJsonInputFieldAndResubmit();
        }

        function deleteEntry(game, uid, displayName) {
            if (!confirm(`Delete ${displayName} from ${game}?`)) return;
            if (!games[game]["Roster"]) return;

            games[game]["Roster"] = games[game]["Roster"].filter(entry => {
                const matchUID = uid ? entry.UID === uid : true;
                return !(matchUID && entry["Display Name"] === displayName);
            });

            UpdateJsonInputFieldAndResubmit();
        }
        //#endregion

        //#region Show relevant tabs
        function toggleEntryTabs(tabId) {
            if (tabId != "All Games") {

                if (arrayContains(tabId, entryTabsBeingShown)) {
                    entryTabsBeingShown = entryTabsBeingShown.filter(function (a) { return a !== tabId })
                }
                else {
                    entryTabsBeingShown.push(tabId);
                }

            }
            else {

                entryTabsBeingShown = []
            }
            showEntryTabs();

        }

        function toggleStatsTabs(tabId) {
            if (tabId != "All Games") {

                if (arrayContains(tabId, statsTabsBeingShown)) {
                    statsTabsBeingShown = statsTabsBeingShown.filter(function (a) { return a !== tabId })
                }
                else {
                    statsTabsBeingShown.push(tabId);
                }

            }
            else {

                statsTabsBeingShown = []
            }
            OnStatsFilterChange();
        }

        function trackFormChanges(form) {
            const original = JSON.parse(form.getAttribute("data-original").replace(/&apos;/g, "'"));

            const checkForChanges = () => {
                const current = {
                    "Display Name": form.displayName.value,
                    "Notes": form.notes.value,
                    "Status": form.status.checked,
                    "Legend": form.legend.checked,
                    "In The Post": form.inThePost.checked,
                    "Figure Details": form.figureDetails.value,
                    "Personal Ranking": form.personalRanking.value
                };

                const changed = Object.keys(current).some(key => {
                    return current[key] != original[key];
                });

                form.parentElement.classList.toggle("unsaved", changed);
            };

            // Listen for changes on all inputs inside this form
            form.querySelectorAll("input").forEach(input => {
                input.addEventListener("input", checkForChanges);
                input.addEventListener("change", checkForChanges);
            });
        }

        function GetUIDStatusAverage(uid) {
            let total = 0;
            let count = 0;

            for (const gameID in games) {
                if(gameID == "Misc/Non-Game" && !entryTabsBeingShown.includes("Misc/Non-Game"))
                {
                    continue;
                }
                let roster = games[gameID]["Roster"];
                //console.log(data[gameID]);
                if (!Array.isArray(roster)) {
                    roster = [roster];
                }

                for (const wrestler of roster) {
                    if (String(wrestler.UID) === String(uid)) {
                        if (wrestler.Status === true) {
                            total += 1;
                        }
                        count += 1;
                    }
                }
            }

            if (count === 0) return 0;
            return Math.round((total / count) * 100);
        }

        function ShowUIDStatusAverageInColourText(uid, games) {
            let percentage = GetUIDStatusAverage(uid);
            return `<p style="color:${getPercentageColor(percentage)}; display:inline">${percentage}%</p>`;
        }

        function getPercentageColor(percentage) {

            return getGradientColor(['#FF0000', '#7FFF00'], percentage);
        }

        function getGradientColor(colors, percentage) {

            if (percentage === undefined) {
                console.error("Pass in a percentage to get a colour");
                return;
            }
            // Clamp percentage between 0 and 100
            percentage = Math.max(0, Math.min(100, percentage));

            // If there's only one color, return it
            if (colors.length === 1) return colors[0];

            // Find the two colors to interpolate between
            const index = (colors.length - 1) * percentage / 100;
            const i = Math.floor(index);
            const t = index - i;

            const color1 = colors[i];
            const color2 = colors[Math.min(i + 1, colors.length - 1)];

            // Interpolate between the two colors
            const rgb = [0, 1, 2].map(j => {
                const c1 = parseInt(color1.slice(1 + j * 2, 3 + j * 2), 16);
                const c2 = parseInt(color2.slice(1 + j * 2, 3 + j * 2), 16);
                return Math.round(c1 * (1 - t) + c2 * t);
            });

            // Convert RGB to hex
            return '#' + rgb.map(c => c.toString(16).padStart(2, '0')).join('');
        }

        function OnEntriesFilterChange() {
            renderEntries();
        }

        function SearchForUID(uid) {
            entryFilterInputs.displayName.value = `uid:${uid}`;
            OnEntriesFilterChange();
        }
        //#endregion

        //#region Stats
        const statsFilterInputs =
        {
            status: document.getElementById("statsStatusFilter"),
            legend: document.getElementById("statsLegendFilter"),
            inThePost: document.getElementById("statsPostalFilter")
        }


        function renderStats() {
            const statsFilter =
            {
                "Status": statsFilterInputs.status.value,
                "Display Name": "", //we don't use this in stats mode
                "Legend": statsFilterInputs.legend.value,
                "In The Post": statsFilterInputs.inThePost.value
            };

            //game tab creation
            const tabs = document.getElementById("statsTabs");
            tabs.innerHTML = "";

            CreateTabButton("All Games", () => toggleStatsTabs("All Games"), "StatsTabButton", tabs);

            const wrestlerScores = {}; // uid -> { missing, total, name, missingName } //sometimes a specific gimmick name is missing - e.g. gregory helms, not the hurricane
            const gameAverages = {}

            for (const game in games) {
                //Tab HTML
                CreateTabButton(game, () => toggleStatsTabs(game), "StatsTabButton", tabs);

                if (game != "Misc/Non-Game") {
                    //Do we care about this game
                    if (statsTabsBeingShown.length == 0 || arrayContains(game, statsTabsBeingShown)) {

                        if (games[game]["Roster"]) {
                            const sortedRoster = [...games[game]["Roster"]].sort((a, b) => {
                                return a["Display Name"]?.localeCompare(b["Display Name"]);
                            });

                            const average = { "got": 0, "total": 0 }

                            sortedRoster.forEach((entry, index) => {
                                if (WrestlerShouldBeShown(entry, statsFilter)) {

                                    const uid = entry["UID"];
                                    if (!uid) return; // Skip if no UID - don't worry, return exits the anonymous function for this one wrestler, not the entire loop

                                    //I need it ranking - also total is used for appearance counting
                                    wrestlerScores[uid] = wrestlerScores[uid] ?? { missing: 0, total: 0, name: entry["Display Name"] };
                                    wrestlerScores[uid].total += 1; // it appeared
                                    average["total"] += 1;
                                    if (!entry.Status) {
                                        wrestlerScores[uid].missing += 1; //I have it, add to the total
                                        wrestlerScores[uid].missingName = wrestlerScores[uid].missingName ?? entry["Display Name"]
                                    }
                                    else {
                                        average["got"] += 1;
                                    }
                                }
                            })

                            gameAverages[game] = average["total"] != 0 ? Math.round((average["got"] / average["total"]) * 100) : 100;
                        }
                        else {
                            gameAverages[game] = 100;
                        }
                    }
                }
            };


            const statsContainer = document.getElementById("statsContainer");
            statsContainer.innerHTML = "";

            const gameStatsDiv = createStatsListcontainer(statsContainer, "Game Stats", "gameRankings")
            let listDiv = gameStatsDiv.appendChild(document.createElement("ol"))
            let sortedGames = Object.entries(gameAverages).sort((a, b) => b[1] - a[1]);

            sortedGames.forEach((gameEntry) => {
                const colorHex = getPercentageColor(gameEntry[1]);
                AppendName(listDiv, `<span style="color: ${colorHex}">${gameEntry[0]}</span> - ${gameEntry[1]}%`);
            });

            if (statsTabsBeingShown.length === 1) {
                if (arrayContains(statsTabsBeingShown, "Misc/Non-Game")) {

                    gameStatsDiv.innerHTML = "Pick a game to see stats (misc isn't a game)"
                    UpdateStatsTabCSS(); // apply highlight effect if being displayed
                    return;
                }
            }
            else {
                //most in-game appearances
                const appearanceRankingCount = 10;
                const mostAppearancesDiv = createStatsListcontainer(statsContainer, `Top ${appearanceRankingCount} By Appearance Count`, "mostWrestlerAppearances")
                listDiv = mostAppearancesDiv.appendChild(document.createElement("ol"))
                // Convert to array of [uid, count] pairs
                let sortedUIDs = Object.entries(wrestlerScores)
                    .sort((a, b) => b[1].total - a[1].total) // Sort descending by count
                    .slice(0, appearanceRankingCount);



                sortedUIDs.forEach(([uid, count], index) => {
                    const colorHex = getPercentageColor(((wrestlerScores[uid].total - wrestlerScores[uid].missing) / wrestlerScores[uid].total) * 100);
                    AppendClickableName(listDiv, `<span style="color: ${colorHex}">${count.name}</span> (${count.total} appearances)`, uid);
                });
            }


            //biggest score = "I need it" ranking
            const biggestScoreDiv = createStatsListcontainer(statsContainer, "Top __ to Watch For!", "topScores")
            listDiv = biggestScoreDiv.appendChild(document.createElement("ol"))
            // Convert to array of [uid, missing] and sort
            sortedUIDs = Object.entries(wrestlerScores)
                .map(([uid, { missing, total, name, missingName }]) => { return [uid, missing, total, name, missingName]; }) //subtract owned as I'm interested in the ones that I don't have for this
                .sort((a, b) => b[1] - a[1]) // Sort by missing count

            let counter = 0;
            sortedUIDs.forEach(([uid, missing, total, name, missingName], index) => {

                if (missing > 0) {
                    const colorHex = getPercentageColor(((wrestlerScores[uid].total - wrestlerScores[uid].missing) / wrestlerScores[uid].total) * 100);

                    if (missingName !== undefined && missingName != name) {
                        AppendClickableName(listDiv, `<span style="color: ${colorHex}">${missingName} (aka ${name})</span> — Missing ${missing}/${total}`, uid);
                    }
                    else {
                        AppendClickableName(listDiv, `<span style="color: ${colorHex}">${name}</span> — Missing ${missing}/${total}`, uid);
                    }
                    counter++;
                }
            });

            if(counter > 0)
            {
                biggestScoreDiv.parentElement.querySelector("h3").innerText = `Here's ${counter} to watch for!`;
            }
            else
            {
                biggestScoreDiv.parentElement.querySelector("h3").innerText = `No missing wrestlers to show!`;
            }
            UpdateStatsTabCSS(); //apply highlight effect if being displayed
            //PrintGamesInChronologicalOrder();
        }

        // function PrintGamesInChronologicalOrder() {

        //     const entries = Object.entries(games);

        //     // Sort the entries by ReleaseDate
        //     entries.sort(([, aData], [, bData]) => {
        //         const aDate = new Date(aData["ReleaseDate"]);
        //         const bDate = new Date(bData["ReleaseDate"]);
        //         return aDate - bDate; // For chronological order (earliest to latest)
        //     });

        //     for (const [gameName, gameData] of entries) {
        //         console.log(`${gameName}: ${gameData["ReleaseDate"]}`);
        //     }
        // }

        function AppendName(div, textToShow) {
            let text = document.createElement("li");
            text.innerHTML = textToShow;
            text.classList.add("noWrap");
            div.appendChild(text);
            div.appendChild(document.createElement("br"));
        }

        //onclick SearchForUID
        function AppendClickableName(div, textToShow, uid) {
            let text = document.createElement("li");
            text.classList.add("noWrap");
            text.innerHTML = textToShow;
            text.onclick = function () { SearchForUID(parseInt(uid)); };
            div.appendChild(text);
            div.appendChild(document.createElement("br"));
        }

        function createStatsListcontainer(parentDiv, text, newID) {
            const container = document.createElement("div");
            const childDiv = document.createElement("div");
            childDiv.id = newID
            let header = document.createElement("h3");
            header.innerText = text;
            container.appendChild(header);
            container.appendChild(childDiv);
            parentDiv.appendChild(container);
            return childDiv;
        }

        function UpdateStatsTabCSS() {


            for (const gameID in games) {
                if (statsTabsBeingShown.length == 0 || arrayContains(gameID, statsTabsBeingShown)) {

                    // Show selected tab and mark button active
                    document.getElementById(`StatsTabButton${gameID}`).classList.remove('tab-btn');
                    document.getElementById(`StatsTabButton${gameID}`).classList.add('tab-btn-active');
                }
                else {
                    document.getElementById(`StatsTabButton${gameID}`).classList.remove('tab-btn-active');
                    document.getElementById(`StatsTabButton${gameID}`).classList.add('tab-btn');
                }
            }
        }

        function OnStatsFilterChange() {
            renderStats();
        }
        //#endregion

        //#region Utility
        function arrayContains(needle, arrhaystack) {
            return (arrhaystack.indexOf(needle) > -1);
        }

        function CreateTabButton(game, onclick, idPrefix, tabs) {
            //All games tab
            tabButton = document.createElement("button");
            tabButton.innerHTML = game;
            tabButton.classList.add("tab-btn");
            tabButton.id = `${idPrefix}${game}`;
            tabButton.addEventListener('click', onclick);
            tabs.appendChild(tabButton);
        }


        function WrestlerShouldBeShown(wrestler, filters) {
            //Sanitise, nullcheck etc
            const status = String(wrestler["Status"]) == "undefined" ? "false" : String(wrestler["Status"]);
            const legend = String(wrestler["Legend"]) == "undefined" ? "false" : String(wrestler["Legend"]);
            const inThePost = String(wrestler["In The Post"]) == "undefined" ? "false" : String(wrestler["In The Post"]);
            const displayNameToLower = wrestler["Display Name"]?.toLowerCase() || "";
            return (filters["Status"] === "all" || filters["Status"] === status) &&
                (filters["Legend"] === "all" || filters["Legend"] === legend) &&
                (filters["In The Post"] === "all" || filters["In The Post"] === inThePost) &&
                (filters["Display Name"] === "" || displayNameToLower.includes(filters["Display Name"]) || (filters["Display Name"].startsWith("uid:") && filters["Display Name"].substring(4) == wrestler["UID"]))
        }

        //autobackup!
        window.addEventListener("beforeunload", () => {
            localStorage.setItem("draftJson", document.getElementById("JsonInputField").value);
        });
        window.addEventListener("DOMContentLoaded", () => {
            const saved = localStorage.getItem("draftJson");
            if (saved) document.getElementById("JsonInputField").value = saved;
        });
        //#endregion
    </script>
</body>

</html>